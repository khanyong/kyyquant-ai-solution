-- Check existing trading_signals table structure
SELECT
  column_name,
  data_type,
  is_nullable,
  column_default
FROM information_schema.columns
WHERE table_name = 'trading_signals'
  AND table_schema = 'public'
ORDER BY ordinal_position;

-- Drop existing table and recreate with correct schema
DROP TABLE IF EXISTS public.trading_signals CASCADE;

-- Create trading_signals table for storing trading signals generated by n8n workflow
CREATE TABLE public.trading_signals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Strategy and stock info
  strategy_id uuid NOT NULL REFERENCES strategies(id) ON DELETE CASCADE,
  stock_code varchar(20) NOT NULL,
  stock_name varchar(100),

  -- Signal details
  signal_type varchar(10) NOT NULL CHECK (signal_type IN ('BUY', 'SELL', 'HOLD')),
  signal_strength decimal(5,2), -- 0-100 scale

  -- Price and volume data
  current_price decimal(15,2),
  volume bigint,

  -- Conditions met
  conditions_met jsonb, -- Array of conditions that were satisfied

  -- Metadata
  created_at timestamp with time zone DEFAULT now(),
  processed boolean DEFAULT false,
  processed_at timestamp with time zone,

  -- Indexes
  CONSTRAINT trading_signals_stock_code_check CHECK (char_length(stock_code) > 0)
);

-- Create indexes for performance
CREATE INDEX idx_trading_signals_strategy_id ON trading_signals(strategy_id);
CREATE INDEX idx_trading_signals_stock_code ON trading_signals(stock_code);
CREATE INDEX idx_trading_signals_created_at ON trading_signals(created_at DESC);
CREATE INDEX idx_trading_signals_signal_type ON trading_signals(signal_type);
CREATE INDEX idx_trading_signals_processed ON trading_signals(processed) WHERE NOT processed;

-- Enable RLS
ALTER TABLE public.trading_signals ENABLE ROW LEVEL SECURITY;

-- Create policies
DROP POLICY IF EXISTS "Users can view signals for their strategies" ON public.trading_signals;
CREATE POLICY "Users can view signals for their strategies"
  ON public.trading_signals
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM strategies s
      WHERE s.id = strategy_id
        AND s.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Service role can insert signals" ON public.trading_signals;
CREATE POLICY "Service role can insert signals"
  ON public.trading_signals
  FOR INSERT
  TO service_role
  WITH CHECK (true);

DROP POLICY IF EXISTS "Anon can insert signals" ON public.trading_signals;
CREATE POLICY "Anon can insert signals"
  ON public.trading_signals
  FOR INSERT
  TO anon
  WITH CHECK (true);

DROP POLICY IF EXISTS "Users can update own signals" ON public.trading_signals;
CREATE POLICY "Users can update own signals"
  ON public.trading_signals
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM strategies s
      WHERE s.id = strategy_id
        AND s.user_id = auth.uid()
    )
  );

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON public.trading_signals TO authenticated;
GRANT INSERT ON public.trading_signals TO anon;
GRANT ALL ON public.trading_signals TO service_role;

-- Create a function to clean up old signals (older than 30 days)
CREATE OR REPLACE FUNCTION public.cleanup_old_trading_signals()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM trading_signals
  WHERE created_at < NOW() - INTERVAL '30 days'
    AND processed = true;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

GRANT EXECUTE ON FUNCTION public.cleanup_old_trading_signals TO authenticated, service_role;

-- Verification
SELECT
  tablename,
  schemaname
FROM pg_tables
WHERE tablename = 'trading_signals';

-- Show columns
SELECT
  column_name,
  data_type,
  is_nullable,
  column_default
FROM information_schema.columns
WHERE table_name = 'trading_signals'
  AND table_schema = 'public'
ORDER BY ordinal_position;

-- Show indexes
SELECT
  indexname,
  indexdef
FROM pg_indexes
WHERE tablename = 'trading_signals'
ORDER BY indexname;
