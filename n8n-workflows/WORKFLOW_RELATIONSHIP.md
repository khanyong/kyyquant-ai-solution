# 워크플로우 간 연결성 및 역할

## 📊 워크플로우 개요

### 1. 워크플로우 B v6 (자동 매매 실행)
- **역할**: 실제 주문 생성 및 실행
- **실행 주기**: 5분마다
- **주요 기능**: 전략 기반 매수/매도 주문 자동 생성

### 2. 자동매매 모니터링 v38
- **역할**: 현재가 수집 및 저장 (전략 유니버스 종목)
- **실행 주기**: 주기적 (1~2시간마다 권장)
- **주요 기능**: 키움 API 호가 조회 → `kw_price_current` 테이블 저장

## 🔄 워크플로우 간 데이터 흐름

```
┌─────────────────────────────────────────────────────────────┐
│                      전체 자동매매 시스템                        │
└─────────────────────────────────────────────────────────────┘

┌──────────────────────┐          ┌──────────────────────┐
│  자동매매 모니터링 v38  │          │   워크플로우 B v6     │
│  (현재가 수집/저장)    │          │  (주문 생성/관리)     │
└──────────────────────┘          └──────────────────────┘
         │                                    │
         │ 1~2시간마다                        │ 5분마다
         ▼                                    ▼
┌──────────────────────┐          ┌──────────────────────┐
│  1. 전략 조회          │          │  1. 전략 기반 신호 생성 │
│  2. 유니버스 종목 추출  │          │  2. 포지션 확인        │
│  3. 키움 호가 조회     │          │  3. 현재가 조회 ⬅─────┤
│  4. 현재가 계산        │          │     (kw_price_current)│
│  5. kw_price_current  │          │  4. 기존 주문 취소     │
│     테이블 저장        │          │  5. 주문 가격 계산     │
└──────────────────────┘          │  6. 새 주문 생성       │
         │                        └──────────────────────┘
         │ 현재가 저장                       │
         ▼                                 │ 주문 저장
┌──────────────────────┐                  ▼
│ kw_price_current     │          ┌──────────────────────┐
│ - stock_code         │          │   orders 테이블       │
│ - stock_name         │          │  status: PENDING     │
│ - current_price      │          └──────────────────────┘
│ - change_price       │
│ - change_rate        │
│ - volume             │                   ▲
│ - updated_at         │                   │
└──────────────────────┘                   │
         ▲                                 │
         │                                 │
         │ 워크플로우 B가 읽어서 사용 ────────┘
         │ (주문 가격 계산 시)
```

**핵심 데이터 흐름**:

1. **v38 (1~2시간마다)**: 전략 유니버스 종목들의 현재가 수집 → `kw_price_current` 저장
2. **워크플로우 B (5분마다)**: `kw_price_current`에서 현재가 읽음 → 주문 가격 계산 → 주문 생성

## 🎯 각 워크플로우의 역할

### 워크플로우 B v6 (주문 생성 및 관리)

#### 주요 기능
1. **전략 기반 신호 생성**
   - 활성 전략 조회
   - 유니버스 종목 추출
   - 진입/청산 조건 평가

2. **포지션 확인**
   - `positions` 테이블 조회
   - 이미 보유한 종목은 스킵
   - 중복 주문 방지

3. **기존 주문 관리**
   - `PENDING` 상태 주문 조회
   - 미체결 주문 자동 취소
   - 가격 재계산 후 재주문

4. **새 주문 생성**
   - 주문 가격 계산 (현재가 + offset)
   - 키움 API 주문 실행
   - `orders` 테이블에 저장 (`status: PENDING`)

#### 사용 테이블
- **읽기**: `strategies`, `positions`, `orders` (PENDING)
- **쓰기**: `trading_signals`, `orders`

#### 실행 조건
- ✅ 평일 09:00 ~ 15:30
- ✅ 5분마다 실행
- ⏸️ 주말 및 장외 시간 중단

---

### 자동매매 모니터링 v38 (현재가 수집)

#### 주요 기능
1. **활성 전략 조회**
   - `strategies` 테이블에서 활성 전략 및 유니버스 종목 조회
   - RPC: `get_active_strategies_with_universe`

2. **종목 코드 추출**
   - 전략별 `filtered_stocks` 배열에서 종목 코드 추출
   - 중복 제거 및 유효성 검증

3. **키움 API 호가 조회**
   - API: `ka10004` (도스탁 시장시세 조회)
   - 매도 1호가(`sel_fpr_bid`) / 매수 1호가(`buy_fpr_bid`)
   - 60초 간격 Rate Limiting

4. **현재가 계산**
   - 추정 현재가 = (매도호가 + 매수호가) / 2
   - 전일종가 조회하여 등락률 계산
   - 거래량 집계

5. **데이터 저장**
   - **kw_stock_master**: 종목 기본 정보 (종목코드, 종목명)
   - **kw_price_current**: 현재가 정보 (가격, 등락률, 거래량)
   - UPSERT 방식 (중복 시 업데이트)

#### 사용 테이블
- **읽기**: `strategies`, `kw_price_daily` (전일종가)
- **쓰기**: `kw_stock_master`, `kw_price_current`

#### 실행 조건
- ✅ 항상 실행 (장시간 체크는 테스트 모드)
- ✅ 1~2시간마다 실행 (설정에 따라 조정 가능)
- ⏸️ (현재는 테스트 모드로 모든 시간 허용)

---

## 🔗 워크플로우 간 연동 시나리오

### 시나리오 1: 현재가 수집 및 주문 생성

```
09:00 - 자동매매 모니터링 v38 실행 (1~2시간마다)
├─ 전략 조회: 활성 전략 및 유니버스 종목
│   - 전략 1: [005930, 000660, 108320]
│   - 전략 2: [035720, 000270]
├─ 키움 API 호가 조회 (60초 간격):
│   - 005930: 매도호가 71,160 / 매수호가 71,140
│   - 000660: 매도호가 89,520 / 매수호가 89,500
│   - 108320: 매도호가 52,070 / 매수호가 52,050
├─ 현재가 계산:
│   - 005930: (71,160 + 71,140) / 2 = 71,150원
│   - 000660: (89,520 + 89,500) / 2 = 89,510원
│   - 108320: (52,070 + 52,050) / 2 = 52,060원
└─ kw_price_current 테이블 저장 (UPSERT):
    - stock_code, stock_name, current_price
    - change_price, change_rate, volume
    - updated_at: 2025-01-13 09:00:00

10:00 - 워크플로우 B v6 실행 (5분마다)
├─ 전략 조회: 삼성전자(005930) 매수 신호
├─ 포지션 확인: 없음 (신규 주문 가능)
├─ 현재가 조회:
│   - SELECT * FROM kw_price_current
│   - WHERE stock_code = '005930'
│   - → current_price: 71,150원 (v38이 저장한 데이터)
├─ 주문 가격 계산:
│   - 기준가: 71,150원
│   - offset: +10원
│   - 주문가: 71,160원
├─ 키움 API 주문: 10주, LIMIT 71,160원
└─ orders 테이블 저장:
    - stock_code: 005930
    - order_price: 71160  ✅ (0이 아님!)
    - quantity: 10
    - status: PENDING
```

**핵심**:
- v38이 주기적으로 현재가를 `kw_price_current`에 저장 (1~2시간 간격)
- 워크플로우 B는 이 테이블에서 현재가를 읽어 주문 가격 계산
- **워크플로우 B는 키움 API를 직접 호출하지 않음** (현재가 조회)

### 시나리오 2: 미체결 주문 재주문

```
10:00 - 워크플로우 B v6
├─ kw_price_current 조회: 52,060원 (v38이 09:00에 저장)
├─ 주문 생성: LX세미콘(108320), 52,070원, 10주
└─ orders 테이블: PENDING

10:05 - 워크플로우 B v6 재실행
├─ 포지션 확인: 없음 (미체결)
├─ 기존 주문 확인: PENDING 1건 발견 (52,070원)
├─ 주문 취소: status → CANCELLED
├─ kw_price_current 재조회:
│   - updated_at: 09:00 (아직 v38 갱신 전)
│   - current_price: 52,060원 (같은 값)
├─ 새 주문가 계산: 52,070원
└─ 새 주문 생성: 52,070원, PENDING

11:00 (또는 그 이후) - 자동매매 모니터링 v38 재실행
├─ 키움 API 호가 재조회:
│   - 108320: 매도호가 52,010 / 매수호가 51,990
├─ 현재가 재계산: 52,000원 (가격 하락!)
└─ kw_price_current 업데이트: 52,000원

11:05 - 워크플로우 B v6 재실행
├─ 포지션 확인: 없음
├─ 기존 주문 확인: PENDING 1건 (52,070원)
├─ 주문 취소: CANCELLED
├─ kw_price_current 조회: 52,000원 (갱신된 가격!)
├─ 새 주문가 계산: 52,010원
└─ 새 주문 생성: 52,010원, PENDING
```

**핵심**:
- v38이 주기적으로 현재가를 갱신 (1~2시간 간격)
- 워크플로우 B는 5분마다 주문을 재계산
- v38의 갱신 주기 내에서는 같은 가격 사용 (캐싱 효과)

---

## 📊 데이터베이스 테이블 관계

### kw_price_current 테이블 ⭐ (핵심)
- **생성/업데이트**: 자동매매 모니터링 v38
- **조회**: 워크플로우 B v6 (주문 가격 계산)
- **주요 필드**:
  - `stock_code`: 종목 코드 (PK)
  - `stock_name`: 종목명
  - `current_price`: 현재가 (매도/매수 호가 평균)
  - `change_price`: 등락가
  - `change_rate`: 등락률
  - `volume`: 거래량
  - `updated_at`: 최종 업데이트 시각 (v38 실행 시각)
- **역할**: **v38과 워크플로우 B를 연결하는 중앙 데이터 저장소**

### kw_stock_master 테이블
- **생성/업데이트**: 자동매매 모니터링 v38
- **주요 필드**:
  - `stock_code`: 종목 코드 (PK)
  - `stock_name`: 종목명
  - `market`: 시장 구분 (KOSPI/KOSDAQ)
- **역할**: 종목 기본 정보 마스터 테이블

### orders 테이블
- **생성**: 워크플로우 B v6
- **주요 필드**:
  - `status`: PENDING / EXECUTED / CANCELLED
  - `order_price`: 주문 가격 (kw_price_current 기반 계산)
  - `quantity`: 주문 수량
  - `kiwoom_order_no`: 키움 주문번호

### positions 테이블
- **조회**: 워크플로우 B v6 (중복 주문 방지)
- **주요 필드**:
  - `quantity`: 보유 수량 (0보다 크면 보유중)
  - `avg_price`: 평균 매입 단가

### trading_signals 테이블
- **생성**: 워크플로우 B v6
- **용도**: 신호 이력 기록 (분석용)

---

## ⚙️ 시간 설정 이유

### 자동매매 모니터링 v38: 1~2시간 간격
- ✅ **현재가 갱신 주기**: 1~2시간마다 유니버스 종목들의 현재가 갱신
- ✅ **API 비용 절감**: 키움 API Rate Limit 고려 (60초 간격 batching)
- ✅ **충분한 실시간성**: 주식 가격은 1~2시간 내에서도 큰 트렌드 유지
- ⚠️ **트레이드오프**: 간격이 길수록 API 비용↓, 가격 정확도↓

### 워크플로우 B: 5분 간격
- ✅ **주문 갱신 주기**: 미체결 주문을 5분마다 재계산하여 체결 확률 증가
- ✅ **v38 데이터 활용**: kw_price_current에서 현재가 조회 (API 호출 없음)
- ✅ **빠른 대응**: v38이 1시간마다 갱신하는 가격을 5분마다 재활용
- ✅ **시장 변동 반영**: 주문 가격은 자주 갱신하되, 현재가 조회는 v38에 의존

---

## 🔐 의존성 및 필수 조건

### 워크플로우 B v6 → 모니터링 v38

**의존 관계**:
- **v38이 생성한 `kw_price_current` 테이블을 B가 조회** ⭐ (핵심!)
- B가 생성한 `orders`를 다른 시스템(체결 모니터링)이 처리
- B가 조회하는 `positions`는 체결 시 생성됨

**필수 조건**:

1. ✅ **v38 먼저 실행 필수**
   - B가 실행되기 전에 v38이 최소 1회 실행되어야 함
   - v38이 `kw_price_current` 테이블에 데이터를 저장해야 B가 조회 가능
   - 없으면 B의 "현재가 조회" 노드에서 빈 결과 반환

2. ✅ `kw_price_current` 테이블 존재 및 데이터
   - B는 이 테이블에서 `current_price` 읽음
   - 테이블이 없거나 데이터가 없으면 `order_price = 0` 버그 발생

3. ✅ 전략 유니버스 일치
   - v38이 수집하는 종목 = B가 주문하는 종목
   - `get_active_strategies_with_universe` RPC가 같은 결과 반환

4. ✅ 두 워크플로우 모두 활성화
   - **v38만 실행**: 현재가만 수집, 주문 생성 안 됨
   - **B만 실행**: 현재가 데이터 없어 주문 가격 계산 불가 (order_price = 0)

---

## 🚨 주의사항

### 1. 워크플로우 실행 순서

**문제 시나리오**:
```
10:00 - 워크플로우 B 실행 → 주문 생성 (PENDING)
10:01 - 모니터링 v38 실행 → 체결 확인, positions 생성
10:05 - 워크플로우 B 실행 → 포지션 확인, 주문 스킵 ✅
```

**정상 작동**: v38이 중간에 체결을 감지하고 포지션 생성

### 2. 시간대 불일치 리스크

**위험 시나리오**:
```
15:29 - 워크플로우 B 실행 → 주문 생성
15:30 - 장 마감, 두 워크플로우 모두 중단
15:31 - 실제 체결 발생 (장 마감 직후)
```

**해결**:
- 15:20 이후 새 주문 생성 중단 (선택적)
- 익일 09:00 첫 v38 실행 시 전일 주문 체결 확인

### 3. 데이터베이스 정합성

**필수**:
- `orders.stock_code` = `positions.stock_code` (정확한 매칭)
- `orders.quantity` = `positions.quantity` (체결 시)
- 트랜잭션 보장 필요 (가능하면 RPC 함수 사용)

---

## 💡 개선 가능 영역

### 1. 부분 체결 처리 개선

**현재**:
```javascript
// 워크플로우 B v6
if (existingPosition && existingPosition.quantity > 0) {
  skip;  // 1주라도 있으면 스킵
}
```

**개선안**:
```javascript
const targetQuantity = 50;  // 목표 수량
const currentQuantity = existingPosition?.quantity || 0;

if (currentQuantity >= targetQuantity) {
  skip;  // 목표 달성
} else {
  // 잔여 수량만큼 추가 주문
  orderQuantity = targetQuantity - currentQuantity;
}
```

### 2. 워크플로우 간 통신

**현재**: 테이블 기반 간접 통신

**개선안**: n8n Webhook 직접 호출
```
워크플로우 B → 주문 생성
             ↓
         Webhook 트리거
             ↓
    모니터링 v38 즉시 실행
```

### 3. 통합 대시보드

**제안**: 두 워크플로우 통합 모니터링 UI
- 워크플로우 B 마지막 실행 시간
- v38 마지막 체결 확인 시간
- 현재 PENDING 주문 수
- 현재 포지션 수

---

## 🎯 결론

### 워크플로우 역할 분리

| 항목 | 자동매매 모니터링 v38 | 워크플로우 B v6 |
|------|---------------------|----------------|
| **주 역할** | 현재가 수집 및 저장 | 주문 생성 및 관리 |
| **실행 주기** | 1~2시간 (조정 가능) | 5분 |
| **핵심 로직** | 전략 → 종목 → 호가 조회 → 저장 | 현재가 조회 → 가격 계산 → 주문 |
| **읽기 테이블** | strategies, kw_price_daily | strategies, positions, kw_price_current |
| **쓰기 테이블** | kw_stock_master, kw_price_current | orders, trading_signals |
| **의존성** | 없음 (독립 실행) | v38이 저장한 kw_price_current |

### 데이터 흐름 요약

```
v38 (1~2시간)        →    kw_price_current    →    워크플로우 B (5분)
[현재가 수집]             [중앙 저장소]             [가격 조회 → 주문]
```

### 함께 작동해야 하는 이유

1. **v38 단독**: 현재가만 수집, 주문 생성 안 됨 → 데이터만 쌓임
2. **B 단독**: 현재가 데이터 없음 → **order_price = 0 버그** 발생
3. **v38 + B**: 완전한 자동매매 시스템 ✅
   - **v38**: 데이터 수집 (키움 API 호출)
   - **B**: 데이터 소비 (주문 생성)

### 핵심 인사이트

두 워크플로우는 **생산자-소비자 패턴**을 따릅니다:

- **생산자 (v38)**: 키움 API에서 현재가 수집 → `kw_price_current` 저장
- **소비자 (B)**: `kw_price_current` 읽음 → 주문 가격 계산 → 주문 생성

이 아키텍처의 장점:
- ✅ API 호출 최소화 (v38만 키움 API 호출)
- ✅ 캐싱 효과 (1~2시간 동안 같은 가격 재사용)
- ✅ 역할 분리 (데이터 수집 vs 비즈니스 로직)
- ✅ 유연한 갱신 주기 조정 (비용 vs 정확도 트레이드오프)

**⚠️ 중요**: v38이 먼저 실행되어 `kw_price_current`에 데이터를 채워야 B가 정상 작동합니다! 🚀
